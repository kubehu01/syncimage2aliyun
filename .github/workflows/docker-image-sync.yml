name: Docker Image Sync

on:
  push:
    branches:
      - main
      - master
    paths:
      - 'images.txt'

jobs:
  sync-images:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Log in to target Docker registry
        run: |
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin ${{ secrets.DOCKER_REGISTRY }}
      
      - name: Sync images
        id: sync
        run: |
          echo "正在读取 images.txt..."
          echo "文件内容："
          cat images.txt
          echo ""
          
          # 收集镜像列表
          images_list=()
          idx=0
          
          while IFS= read -r line; do
            # 跳过空行和注释
            if [[ -z "$line" ]] || [[ "$line" =~ ^[[:space:]]*# ]]; then
              continue
            fi
            
            # 提取 platform 参数
            platform=""
            if [[ "$line" =~ --platform=([^[:space:]]+) ]]; then
              platform="${BASH_REMATCH[1]}"
              line=$(echo "$line" | sed 's/--platform=[^[:space:]]*//g')
            fi
            
            # 解析格式: <源镜像> to <目标镜像>:<标签>
            if [[ "$line" =~ ^([^[:space:]]+)[[:space:]]+to[[:space:]]+([^[:space:]]+):([^[:space:]]+)$ ]]; then
              source="${BASH_REMATCH[1]}"
              target="${BASH_REMATCH[2]}"
              tag="${BASH_REMATCH[3]}"
              
              images_list+=("${source}|${target}|${tag}|${platform}")
              echo "收集镜像 $((++idx)): $source -> ${target}:${tag}"
            fi
          done < images.txt
          
          echo ""
          echo "镜像总数: ${#images_list[@]}"
          echo "开始并发同步..."
          
          # 并发同步函数
          sync_image() {
            local image_info="$1"
            
            # 使用数组提取
            IFS='|' read -ra parts <<< "$image_info"
            local source="${parts[0]}"
            local target="${parts[1]}"
            local tag="${parts[2]}"
            local platform="${parts[3]:-}"  # 默认空字符串
            
            local full_target="${target}:${tag}"
            
            echo ""
            echo "========================================"
            echo "开始同步: $source -> $full_target"
            if [[ -n "$platform" ]]; then
              echo "指定平台: $platform"
            else
              echo "使用默认平台"
            fi
            echo "========================================"
            
            # 拉取镜像
            local pull_result=0
            if [[ -n "$platform" ]]; then
              echo "执行: docker pull --platform=$platform $source"
              if docker pull --platform="$platform" "$source"; then
                pull_result=0
                echo "✅ 拉取成功"
              else
                pull_result=1
                echo "❌ 拉取失败"
              fi
            else
              echo "执行: docker pull $source"
              if docker pull "$source"; then
                pull_result=0
                echo "✅ 拉取成功"
              else
                pull_result=1
                echo "❌ 拉取失败"
              fi
            fi
            
            if [[ $pull_result -eq 0 ]]; then
              # 标记镜像
              echo "执行: docker tag $source $full_target"
              if docker tag "$source" "$full_target"; then
                echo "✅ 标记成功"
                
                # 推送镜像
                echo "执行: docker push $full_target"
                if docker push "$full_target"; then
                  echo "✅ 推送成功"
                  echo "SUCCESS:$source -> $full_target"
                else
                  echo "❌ 推送失败"
                  echo "FAILED_PUSH:$source -> $full_target"
                fi
              else
                echo "❌ 标记失败"
                echo "FAILED_TAG:$source -> $full_target"
              fi
            else
              echo "❌ 操作失败"
              echo "FAILED_PULL:$source -> $full_target"
            fi
            echo ""
          }
          
          # 并发处理，导出函数供子进程使用
          export -f sync_image
          
          # 记录成功和失败
          failed_images=()
          success_images=()
          
          # 使用临时文件收集结果
          temp_results=$(mktemp)
          
          # 使用 xargs 并发处理（最大4个并发）
          printf '%s\n' "${images_list[@]}" | xargs -n1 -P4 -I{} bash -c 'sync_image "$@"' _ {} | tee "$temp_results"
          
          # 统计成功和失败
          success_count=$(grep -c "^SUCCESS:" "$temp_results" 2>/dev/null || echo "0")
          failed_count=$(grep -c "^FAILED" "$temp_results" 2>/dev/null || echo "0")
          
          # 简化：直接输出统计
          echo "========================================"
          echo "镜像同步完成"
          echo "成功: ${success_count}"
          echo "失败: ${failed_count}"
          echo "========================================"
          
          if [ "$failed_count" -gt 0 ]; then
            echo "failed=true" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "所有镜像同步成功！"
            echo "failed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Clean up
        if: always()
        run: |
          echo "清理本地镜像..."
          docker image prune -f
          docker system prune -f
      
      - name: Summary
        if: always()
        run: |
          if [ "${{ steps.sync.outputs.failed }}" = "true" ]; then
            echo "❌ 部分镜像同步失败"
            echo "${{ steps.sync.outputs.failed_list }}"
            exit 1
          else
            echo "✅ 所有镜像同步成功"
          fi

